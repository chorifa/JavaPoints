# Mysql

## B-Tree和B+Tree

m阶B树是一棵m路平衡搜索树，每个节点中最多m-1个有序关键码，每个关键码会有一个对应于大于它和小于它的子节点。B+树和B树的不同在于，B+树的叶子节点存放了所有的关键码以及对应记录存放的指针，所有上层非叶子节点的关键码会在刚大于它的叶子节点中的最小位置复写；同时，叶子节点包含指向下一个叶子节点的指针，方便进行范围查询。  

## 存储引擎MyISAM和Innodb

* 存储方式：Innodb采用主键聚簇索引，其余非聚簇索引的形式。MyISAM采用非聚簇索引，数据和索引放在不同的文件中。  
* 并发：Innodb采用行级锁(MVCC)实现非阻塞读，MyISAM没有行级锁，对整张表加锁，对读读使用共享锁，对写使用排它锁。  
* 事务：Innodb支持事务，也就支持4种隔离度；MyISAM不支持事务。  
* 奔溃恢复：Innodb相比MyISAM，奔溃后数据损坏的可能性更小，并且恢复也更快。  

## Innodb中的事务与并发控制  

ACID:  

* 原子性A  
  一个事务不能再分割，要么全部执行成功要么全部失败  
* 一致性C  
  数据库总是从一个一致性的状态转换为另一个一致性的状态。没有提交的事务不会影响数据状态。
* 隔离性I  
  不同事务间具有隔离级别。  
* 持久性D  
  提交的事务就会永久生效。

隔离级别：

* 未提交读 READ UNCOMMITTED  
  事务中的修改即使没有提交也会对其他事务可见。会出现脏读(及以上)  
* 提交读 READ COMMITTED
  一个事务执行中只能看到已经提交事务所做的修改(自己的可以看见)，即一个事务提交前的修改对其他事务不可见。会出现不可重复读(及以上)，不可重复读指在一个事务中进行两次同样的查询可能得到不同的结果，如事务A查询，事务B修改并提交，事务A再查询，则能观测到B的修改，从而出现不一样。  
* 可重复读(MySQL默认) REPEATABLE READ  
  可重复读解决了不可重复读的问题，一个事务中相同的查询得到的结果是相同的。但是理论上会出现幻读，若事务A在范围内查询，事务B在范围内插入一行并提交，事务A再次在该范围内查询，会产生幻行。但MySQL通过MVCC解决了幻读问题。  
* 可串行化 SERIALIZABLE  
  强制事务的串行执行，对读的每行都上锁。  

锁：  

* 行锁：  
  修改某一行数据时施加的锁(隐式获取)，粒度较小。事务中使用两阶段锁，即随时可以获得锁，但是统一在commit或rollback时释放锁。如在事务A中update某一行，未提交前，在另一个事务B中update这行会阻塞。  
  select for update / select lock in shared mode则显式的获取锁，应当尽量避免使用，select for update总能通过修改update语句来避免。  
  InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点 MySQL 与 Oracle 不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB 这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB 才使用行级锁，否则，InnoDB 将使用表锁。  
  不论是使用主键索引、唯一索引或普通索引，InnoDB 都会使用行锁来对数据加锁。  
  只有执行计划真正使用了索引，才能使用行锁：即便在条件中使用了索引字段，但是否使用索引来检索数据是由 MySQL 通过判断不同执行计划的代价来决定的，如果 MySQL 认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下 InnoDB 将使用表锁，而不是行锁。  

* MVCC多版本并发控制(行级锁)：  
  MySQL中的MVCC实际只实现非阻塞读，即读读，读写不阻塞，而写写是阻塞的，使用排它锁。  
  innodB给每个表多添了两列，一列是DATA_TRX_ID，表示更新这列的事务ID，另一列是ROLL_BACK_PTR，指向该行数据的回滚版本。存储引擎全局维护一个活动事务的列表trx_ids，每次新开一个事务给它分配一个递增ID。当执行select时，会复制一份当前的活动事务列表，以及当前已经分配的最大事务编号，作为READ_VIEW。如果某行的DATA_TRX_ID小于活动事务列表的最小事务，说明是在事务开始前就已经提交的，可以读取；如果大于已经分配的最大事务，说明是在select后才提交的，是不可见的，不可以读取；如果在最小未提交和最大分配之间，则看是否在活动事务列表
  中，在的话说明还没有提交，不可见，不在说明已经提交了，可见。不可见的数据从历史版本开始寻找前一个版本，直到符合可见要求。  
  RR和RC的区别在于，RC在每次select时都会产生一次READ_VIEW(复制当前活动事务，已经分配的最大事务编号，最小未提交事务编号)，从而实现已提交就能可见，从而也就有不可重复读的问题。而RR在一个事务中只使用第一次select产生的READ_VIEW，从而能保证可以重复读。

* 间隙锁(next-key locking)：  
  实际上间隙锁(gap lock)只是锁住区间，next-key locking是gap lock + record lock。next-key locking是为了解决幻读问题，首先要弄清一个概念，上边说的MVCC已经可以保证一个事务中的select不会产生幻读，同时也不会阻塞其他事务对区间的insert/update等操作，但是这只是保证了"快照读"不会产生幻读。但是MVCC无法对写(也就是"当前读")生效，如果事务A要在区间内insert，事务B也要在这个区间内update，普通的RR原则上B是可以感知到A的修改的(也就是B发现update的数据行多了A新插入的一行)，也就是"当前读"产生了幻读，因为MVCC和行锁不能消除幻读的影响。但是MySQL是解决了幻读的，方法就是不仅对行上锁，在进行"当前读"时给索引的对应区间也上锁(gap lock)从而不会出现幻读。  

* [MVCC与乐观锁](<https://www.zhihu.com/question/27876575>)(如何将乐观锁用于数据库？)  
  首先MVCC利用基于快照的多版本方式处理的是读写阻塞的问题。对于写写问题，会和常见的悲观锁如2PL或者乐观锁配合，比如MVCC+2PL或MVCC+OCC，在mysql中使用MVCC+2PL的策略，也就是写写是阻塞的。  
  乐观并发控制一般是基于验证的，通过对额外的列进行验证和原子修改来进行并发控制。比如可以使用隐藏列version或是时间戳timestamp，在写时先保存一下当时的version或timestamp，写在私有临时区域中写，写完之后验证是否满足隔离度，version或是timestamp能否compareAndSet成功，如果满足就写commit写数据，否则就回滚。  
  上边说的是数据库底层的并发控制。  
  还有一个业务场景中会出现先select一个字段，然后对这个字段进行复杂的逻辑处理计算一个新值，然后update这个新值。由于select阶段是基于快照不阻塞的，因此虽然整个事务已经会满足MYSQL的隔离度，但可能出现业务上不希望出现的覆盖修改。首先尽量避免这么写，如果没办法调整为单条update语句解决的话，一种方法是显式的加select for update锁，但是这相当于扩大了锁的范围。另一种办法是，显式的增加一列冗余列如version或是timestamp，select时不加显式锁，在update的where中比较version是否被修改过了，如果和select时相同就写成功，不相同就写失败。这种方式有点乐观的思路，不扩大锁的范围，底层还是依赖数据库对写的并发控制(不论是加锁还是OCC)。  

## [LOG与持久性D](<https://zhuanlan.zhihu.com/p/98778890>)  

MySQL中常见的Log有RedoLog和BinLog。  

* RedoLog  
  当修改一条记录时，修改的是内存值，此时形成了脏页。如果要把内存值同步修改到磁盘中，太慢了(因为是随机读写)。这时写的是RedoLog，RedoLog存储的是页的物理变化，并且RedoLog是顺序写并且做了优化(组提交)。  

* BINLOG  
  RedoLog是innodb存储引擎层面实现的，BINLog是MYSQL服务器层面实现的。也就是说，RedoLog只在使用了 innodb 作为存储引擎的 MySQL 上才有，而 binlog，只要你是 MySQL，就会有。  
  和RedoLog不同，BinLog记录的是数据的逻辑变化，近似的可以理解为记录了SQL语句(类似Redis里的AoF?)  
  MySQL 通过 BINLOG 录入执行成功的 INSERT、UPDATE、DELETE 等更新数据的 SQL 语句，并由此实现 MySQL 数据库的恢复和主从复制。MySQL 的恢复机制（复制其实就是在 Slave Mysql 不断做基于 BINLOG 的恢复）有以下特点：  
  一是 MySQL 的恢复是 SQL 语句级的，也就是重新执行 BINLOG 中的 SQL 语句。  
  二是 MySQL 的 Binlog 是按照事务提交的先后顺序记录的， 恢复也是按这个顺序进行的。  
  由此可见，MySQL 的恢复机制要求：在一个事务未提交前，其他并发事务不能插入满足其锁定条件的任何记录，也就是不允许出现幻读。  

* 联系  
  RedoLog是用来在宕机或掉电这种物理情况下保障crash recovery的，也即靠它实现ACID的D。  
  BinLog是用来人工恢复某个时间的状态(比如不小心清空了库，想要恢复)，以及用来主从同步。  
  这两个Log的写入依靠，两阶段提交来维护一致性。简略的来说是Redolog(prepare) -> Binlog(write) -> Redolog(commit)  

## 索引  

### 表的数据完整性——约束

* 非空约束 not null  
* 主键约束 primary key  
* 外键约束 一个表(子表)的字段必须依赖另一个表(父表)的字段  
  如表A中a字段引用B表中b字段作为外键，那么a字段的值必须要在b字段中存在。对于修改约束b而言有多种策略，restrict策略：不允许修改b的值；cascade：同步更新，修改b也得修改a；set null：修改b将对应a设为NULL。  
  外键使得查询需要额外的查询另一张表，修改时也需要额外的另一张表的锁，这就使得可能存在死锁。  
  如果时刻需要保证两张表的某个字段的一致性，外键可能比在应用程序中实现更高效；然而如果只是为了做约束，那么不使用外键，在应用程序中进行校验更合适。  
* 检查约束 check(expr)  
* 唯一约束 unique key  

### 匹配原则  

可用匹配：  

* 全值匹配：完全符合索引进行等式匹配  
* 最左匹配：只使用索引的左边列  
* 匹配列前缀：可以只匹配某列的最左前缀(如char索引匹配以A开头的记录)，需要满足最左匹配  
* 精确匹配某一列，在范围匹配某一列
* 覆盖索引：如果要查询的内容完全被索引包含了，那么就不用再去回表

索引限制：  
必须最左匹配，如果有索引(A,B,C)那么A=,C=条件是只能用到索引里的A；当某个列使用范围查询时，右边的列都不能在使用索引，如A=,B>,C=那么C是用不了索引的。  

* 假设有索引A，索引B那么where A= ， B=能用到多少索引？原则上只能用A或B，但是MySQL可能做了优化，优化为类似 where A= Union All where B= and A<>来用到两个索引。  

* 组合索引的顺序，选择性大的放在前边(能筛去更多数据)  

### 聚簇索引  

所谓聚簇索引是指数据行存放在索引的叶子节点中，并且同一个叶子页(默认16K)中数据行紧凑的存储在一起。这就使得对聚簇索引的搜索最终能直接获得整行的所有数据，不需要再另外寻址，速度更快。但是需要注意，插入新数据行或者索引被更新时，可能出现页分裂的问题。  

InnoDB默认对主键进行聚簇索引，如果没有显示定义主键，则会挑选一个unique索引，如果没有会隐式定义一个主键作为聚簇索引。其余二级索引的叶子节点存放的key值+主键值，因此二级索引需要两次查找，除非是覆盖索引的情况。  

MyISAM中每个索引的叶子节点存放的数据行的物理位置，而不是聚簇索引那样的存储在一起。  

InnoDB中主键常见的自增主键，能够使得每个数据行的插入都在前一行的后边，如果页满了，就写新的页，没有页分裂和页碎片，时间和空间的效率都很高。如果主键的值不顺序，非常随机，那么插入一个数据行到一个页中会强制移动插入位置后的所有数据行；同时如果这个页没有被load到内存中，还需要额外的IO；此外，如果插入到一个已满的页中，会导致页分裂，出现页碎片，导致占用更多存储空间。  

### 覆盖索引  

如果一个二级索引包含了某次查询需要的全部列，那么就可以不用回表查询。注意二级索引还有隐含的列信息(主键列)。注意仍旧需要符合索引匹配原则，比如匹配字符串的中段也没办法用索引，仍旧需要回表。  

### 使用索引进行排序  

假设存在索引(A,B,C)
若where A= Order by B desc，第一列A是常量，因此和Order的BC合起来形成了最左匹配，可以用到索引。  
若where A> order by A,B，也可以用到索引，因为order的A，B符合最左匹配。  
